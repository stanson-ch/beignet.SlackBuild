Some GCC warnings fixes

--- a/backend/src/ir/immediate.hpp
+++ b/backend/src/ir/immediate.hpp
@@ -156,7 +156,7 @@ namespace ir {
       else                                                      \
         this->data.p = &defaultData;                            \
       defaultData = 0ull;                                       \
-      memcpy(this->data.FIELD, FIELD, ELEMNUM * getTypeSize()); \
+      memcpy(static_cast<void*>(this->data.FIELD), FIELD, ELEMNUM * getTypeSize()); \
     }
 
     DECL_CONSTRUCTOR(bool, b, TYPE_BOOL, elemNum)
--- a/backend/src/libocl/include/ocl.h
+++ b/backend/src/libocl/include/ocl.h
@@ -121,8 +121,8 @@
 #define cl_khr_spir
 #define cl_khr_fp16
 #define cl_khr_3d_image_writes
-#define cl_intel_subgroups
-#define cl_intel_subgroups_short
+//#define cl_intel_subgroups
+//#define cl_intel_subgroups_short
 
 #if __clang_major__*10 + __clang_minor__ > 40
 #define cl_intel_required_subgroup_size
--- a/utests/utest_generator.py
+++ b/utests/utest_generator.py
@@ -143,15 +143,15 @@
       printf_c("%s expect:%s\\n", log, ULPSIZE);
 #else
     if (std::isinf(cpu_data[index])){
-      sprintf(log, "%s expect:%s\\n", log, INFORNAN);
+      loff += sprintf(log + loff, " expect:%s\\n", INFORNAN);
       OCL_ASSERTM(std::isinf(gpu_data[index]) || fast_math,log);
     }
     else if (std::isnan(cpu_data[index])){
-      sprintf(log, "%s expect:%s\\n", log, INFORNAN);
+      loff += sprintf(log + loff, " expect:%s\\n", INFORNAN);
       OCL_ASSERTM(std::isnan(gpu_data[index]) || fast_math,log);
     }
     else{
-      sprintf(log, "%s expect:%s\\n", log, ULPSIZE);
+      loff += sprintf(log + loff, " expect:%s\\n", ULPSIZE);
       if (ULPSIZE < 0)
             OCL_ASSERTM(gpu_data[index] == cpu_data[index], log);
       else
@@ -343,6 +343,7 @@
   int index;
   %s gpu_data[count_input] = {0}, cpu_data[count_input] = {0}, diff=0.0;
   char log[1024] = {0};
+  int loff = 0;
 
   OCL_CREATE_KERNEL(\"%s_%s\");
   OCL_CREATE_BUFFER(buf[0], CL_MEM_READ_WRITE, count_input * sizeof(%s), NULL); 
@@ -377,7 +378,7 @@
     text = ''' memcpy(gpu_data, buf_data[0], sizeof(gpu_data)); '''
     funcline += [ text ]
 
-    funcsprintfa='    sprintf(log, \"'
+    funcsprintfa='    loff = sprintf(log, \"'
     funcsprintfb=''
     if (self.returnVector(index) == 1 and self.argvector(0,index) != 1):
       funccompare='''
--- a/utests/utest_generator.py
+++ b/utests/utest_generator.py
@@ -168,9 +168,9 @@
         paraTypeList['string'],paraTypeList['string'],\
         paraTypeList['string'],paraTypeList['%s'%(returnType)],\
         paraTypeList['string'],paraTypeList['%s'%(returnType)],\
-        paraTypeList['string'],paraTypeList['string'],\
-        paraTypeList['string'],paraTypeList['string'],\
-        paraTypeList['string'],paraTypeList['%s'%(returnType)])
+        paraTypeList['string'],\
+        paraTypeList['string'],\
+        paraTypeList['%s'%(returnType)])
 
   return text
 
--- a/utests/utest.hpp
+++ b/utests/utest.hpp
@@ -122,7 +122,7 @@
       std::cout << "    [SUCCESS]" << std::endl; \
       UTest::retStatistics.passCount += 1; \
     } \
-    catch (Exception e) { \
+    catch (Exception& e) { \
       std::cout << "    [FAILED]" << std::endl; \
       std::cout << "    " << e.what() << std::endl; \
       UTest::retStatistics.failCount++; \
--- a/utests/utest_run.cpp
+++ a/utests/utest_run.cpp
@@ -82,7 +82,7 @@
         try {
           UTest::run(optarg);
         }
-        catch (Exception e){
+        catch (Exception& e){
           std::cout << "  " << e.what() << "    [SUCCESS]" << std::endl;
         }
 
@@ -97,7 +97,7 @@
           UTest::runMultiThread(optarg);
 #endif
         }
-        catch (Exception e){
+        catch (Exception& e){
           std::cout << "  " << e.what() << "    [SUCCESS]" << std::endl;
         }
 
@@ -120,7 +120,7 @@
         try {
           UTest::runAll();
         }
-        catch (Exception e){
+        catch (Exception& e){
           std::cout << "  " << e.what() << "    [SUCCESS]" << std::endl;
         }
 
@@ -130,7 +130,7 @@
         try {
           UTest::runAllNoIssue();
         }
-        catch (Exception e){
+        catch (Exception& e){
           std::cout << "  " << e.what() << "    [SUCCESS]" << std::endl;
         }
 
@@ -140,7 +140,7 @@
         try {
           UTest::runAllBenchMark();
         }
-        catch (Exception e){
+        catch (Exception& e){
           std::cout << "  " << e.what() << "    [SUCCESS]" << std::endl;
         }
 
--- a/backend/src/llvm/llvm_gen_backend.cpp
+++ b/backend/src/llvm/llvm_gen_backend.cpp
@@ -4256,8 +4264,7 @@
       case llvm::AtomicRMWInst::Min:  return ir::ATOMIC_OP_IMIN;
       case llvm::AtomicRMWInst::UMax: return ir::ATOMIC_OP_UMAX;
       case llvm::AtomicRMWInst::UMin: return ir::ATOMIC_OP_UMIN;
-      case llvm::AtomicRMWInst::Nand:
-      case llvm::AtomicRMWInst::BAD_BINOP: break;
+      default: break;
     }
     GBE_ASSERT(false);
     return ir::ATOMIC_OP_INVALID;
--- a/CMakeLists.txt	2021-03-04 21:17:42.672940945 +0300
+++ b/CMakeLists.txt	2021-03-04 21:12:10.635929056 +0300
@@ -14,7 +14,7 @@
   find_program(CMAKE_LINKER NAMES xild)
 endif ()
 
-CMAKE_MINIMUM_REQUIRED(VERSION 2.6.0)
+CMAKE_MINIMUM_REQUIRED(VERSION 2.9.0)
 PROJECT(OCL)
 if( ${CMAKE_CXX_COMPILER_ID} STREQUAL "Clang")
   set(COMPILER "CLANG")
--- a/backend/CMakeLists.txt	2017-09-22 11:05:22.000000000 +0300
+++ b/backend/CMakeLists.txt	2021-03-04 21:16:08.264517062 +0300
@@ -1,7 +1,7 @@
 project (GBE)
 set (LIBGBE_VERSION_MAJOR 0)
 set (LIBGBE_VERSION_MINOR 2)
-cmake_minimum_required (VERSION 2.6.0)
+cmake_minimum_required (VERSION 2.9.0)
 
 set (GBE_CMAKE_DIR "${GBE_SOURCE_DIR}/cmake")
 set (CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${GBE_CMAKE_DIR}")
@@ -10,8 +10,8 @@
 # Compilation directives
 ##############################################################
 
-set (GBE_DEBUG_MEMORY false CACHE bool "Activate the memory debugger")
-set (GBE_USE_BLOB false CACHE bool "Compile everything from one big file")
+set (GBE_DEBUG_MEMORY false CACHE BOOL "Activate the memory debugger")
+set (GBE_USE_BLOB false CACHE BOOL "Compile everything from one big file")
 
 
 # Force Release with debug info
diff -urN Beignet-1.3.2-Source/backend/src/llvm/StripAttributes.cpp Beignet-1.3.2-Source.new/backend/src/llvm/StripAttributes.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/StripAttributes.cpp	2017-10-24 09:04:48.000000000 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/StripAttributes.cpp	2021-03-05 00:16:19.571286550 +0300
@@ -107,9 +107,9 @@
        BB != E; ++BB) {
     for (BasicBlock::iterator Inst = BB->begin(), E = BB->end();
          Inst != E; ++Inst) {
-      CallSite Call(&*Inst);
+      CallBase *Call = dyn_cast<CallBase>(&*Inst);
       if (Call)
-        Call.setCallingConv(CallingConv::C);
+        Call->setCallingConv(CallingConv::C);
     }
   }
 
diff -urN Beignet-1.3.2-Source/backend/src/llvm/llvm_bitcode_link.cpp Beignet-1.3.2-Source.new/backend/src/llvm/llvm_bitcode_link.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/llvm_bitcode_link.cpp	2021-03-05 00:22:37.639846823 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/llvm_bitcode_link.cpp	2021-03-04 21:45:52.009357305 +0300
@@ -98,7 +98,7 @@
         if (callFunc && callFunc->getIntrinsicID() != 0)
           continue;
 
-        std::string fnName = call->getCalledValue()->stripPointerCasts()->getName();
+        std::string fnName = call->getCalledOperand()->stripPointerCasts()->getName().str();
 
         if (!MFS.insert(fnName).second) {
           continue;
diff -urN Beignet-1.3.2-Source/backend/src/llvm/llvm_device_enqueue.cpp Beignet-1.3.2-Source.new/backend/src/llvm/llvm_device_enqueue.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/llvm_device_enqueue.cpp	2021-03-05 00:22:37.642846867 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/llvm_device_enqueue.cpp	2021-03-05 00:14:51.650994972 +0300
@@ -45,7 +45,7 @@
       return NULL;
 
     /* This is a fake, to check the function bitcast is for block or not */
-    std::string fnName = Fn->getName();
+    std::string fnName = Fn->getName().str();
     if(fnName.find("_invoke") == std::string::npos)
       return NULL;
 
@@ -119,18 +119,18 @@
       ParamTys.push_back(ty);
     }
     FunctionType* NewFT = FunctionType::get(Fn->getReturnType(), ParamTys, false);
-    Function* NewFn = Function::Create(NewFT, Function::ExternalLinkage, Fn->getName());
+    Function* NewFn = Function::Create(NewFT, Function::ExternalLinkage, Fn->getName().str());
     SmallVector<ReturnInst*, 8> Returns;
 
     Function::arg_iterator NewFnArgIt = NewFn->arg_begin();
     for (Function::arg_iterator I = Fn->arg_begin(), E = Fn->arg_end(); I != E; ++I) {
-      std::string ArgName = I->getName();
+      std::string ArgName = I->getName().str();
       NewFnArgIt->setName(ArgName);
       VMap[&*I] = &(*NewFnArgIt++);
     }
     CloneFunctionInto(NewFn, Fn, VMap, /*ModuleLevelChanges=*/true, Returns);
 
-    Fn->setName("__d" + Fn->getName());
+    Fn->setName("__d" + Fn->getName().str());
     mod->getFunctionList().push_back(NewFn);
     //mod->getOrInsertFunction(NewFn->getName(), NewFn->getFunctionType(),
     //                         NewFn->getAttributes());
@@ -147,7 +147,7 @@
       argTypeNames.push_back(llvm::MDString::get(Context, "char*"));
       argBaseTypeNames.push_back(llvm::MDString::get(Context, "char*"));
       argTypeQuals.push_back(llvm::MDString::get(Context, ""));
-      argNames.push_back(llvm::MDString::get(Context, I->getName()));
+      argNames.push_back(llvm::MDString::get(Context, I->getName().str()));
     }
 
     //If run to here, llvm version always > 3.9, add the version check just for build.
@@ -198,7 +198,7 @@
            * invoke pointer to store the index in the unit's block functions index.*/
           Function *Fn = dyn_cast<Function>(bt->getOperand(0));
 
-          std::string fnName = Fn->getName();
+          std::string fnName = Fn->getName().str();
           int index = -1;
           for(size_t i=0; i<unit.blockFuncs.size(); i++) {
             if(unit.blockFuncs[i] == fnName) {
@@ -241,7 +241,7 @@
             //unnamed call function, parse the use to find the define of called function
             SmallVector<Value*, 16> args(CI->op_begin(), CI->op_end()-1);
 
-            Value *v = CI->getCalledValue();
+            Value *v = CI->getCalledOperand();
             BitCastInst* bt = dyn_cast<BitCastInst>(v);
             if(bt == NULL)
               continue;
@@ -316,7 +316,7 @@
                   ConstantExpr *expr = dyn_cast<ConstantExpr>(c->getOperand(3));
                   BitCastInst *bt = dyn_cast<BitCastInst>(expr->getAsInstruction());
                   Function* f = dyn_cast<Function>(bt->getOperand(0));
-                  blocks[v] = f->getName();
+                  blocks[v] = f->getName().str();
                 }
               }
 
@@ -361,7 +361,7 @@
                   ConstantExpr *expr = dyn_cast<ConstantExpr>(c->getOperand(3));
                   BitCastInst *bt = dyn_cast<BitCastInst>(expr->getAsInstruction());
                   Function* f = dyn_cast<Function>(bt->getOperand(0));
-                  blocks[v] = f->getName();
+                  blocks[v] = f->getName().str();
                 }
               }
             } else if(isa<AllocaInst>(block)) {
diff -urN Beignet-1.3.2-Source/backend/src/llvm/llvm_gen_backend.cpp Beignet-1.3.2-Source.new/backend/src/llvm/llvm_gen_backend.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/llvm_gen_backend.cpp	2021-03-05 00:22:37.653847029 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/llvm_gen_backend.cpp	2021-03-04 23:34:21.750854690 +0300
@@ -376,7 +376,7 @@
           GBE_ASSERT(index == 0);
           return this->_newScalar(value, key, type, index, uniform);
           break;
-        case Type::VectorTyID:
+        case Type::FixedVectorTyID:
         {
           auto vectorType = cast<VectorType>(type);
           auto elementType = vectorType->getElementType();
@@ -743,20 +743,20 @@
 #undef DECL_VISIT_FN
 
     // Emit rounding instructions from gen native function
-    void emitRoundingCallInst(CallInst &I, CallSite &CS, ir::Opcode opcode);
+    void emitRoundingCallInst(CallInst &I, CallBase &CS, ir::Opcode opcode);
     // Emit unary instructions from gen native function
-    void emitUnaryCallInst(CallInst &I, CallSite &CS, ir::Opcode opcode, ir::Type = ir::TYPE_FLOAT);
+    void emitUnaryCallInst(CallInst &I, CallBase &CS, ir::Opcode opcode, ir::Type = ir::TYPE_FLOAT);
     // Emit unary instructions from gen native function
-    void emitAtomicInst(CallInst &I, CallSite &CS, ir::AtomicOps opcode);
+    void emitAtomicInst(CallInst &I, CallBase &CS, ir::AtomicOps opcode);
     // Emit workgroup instructions
-    void emitWorkGroupInst(CallInst &I, CallSite &CS, ir::WorkGroupOps opcode);
+    void emitWorkGroupInst(CallInst &I, CallBase &CS, ir::WorkGroupOps opcode);
     // Emit subgroup instructions
-    void emitSubGroupInst(CallInst &I, CallSite &CS, ir::WorkGroupOps opcode);
+    void emitSubGroupInst(CallInst &I, CallBase &CS, ir::WorkGroupOps opcode);
     // Emit subgroup instructions
-    void emitBlockReadWriteMemInst(CallInst &I, CallSite &CS, bool isWrite, uint8_t vec_size, ir::Type = ir::TYPE_U32);
-    void emitBlockReadWriteImageInst(CallInst &I, CallSite &CS, bool isWrite, uint8_t vec_size, ir::Type = ir::TYPE_U32);
+    void emitBlockReadWriteMemInst(CallInst &I, CallBase &CS, bool isWrite, uint8_t vec_size, ir::Type = ir::TYPE_U32);
+    void emitBlockReadWriteImageInst(CallInst &I, CallBase &CS, bool isWrite, uint8_t vec_size, ir::Type = ir::TYPE_U32);
 
-    uint8_t appendSampler(CallSite::arg_iterator AI);
+    uint8_t appendSampler(User::op_iterator AI);
     uint8_t getImageID(CallInst &I);
 
     // These instructions are not supported at all
@@ -1320,13 +1320,13 @@
 #endif
 
       if(typeNameNode) {
-        llvmInfo.typeName= (cast<MDString>(typeNameNode->getOperand(opID)))->getString();
+        llvmInfo.typeName= (cast<MDString>(typeNameNode->getOperand(opID)))->getString().str();
       }
       if(typeBaseNameNode) {
-        llvmInfo.typeBaseName= (cast<MDString>(typeBaseNameNode->getOperand(opID)))->getString();
+        llvmInfo.typeBaseName= (cast<MDString>(typeBaseNameNode->getOperand(opID)))->getString().str();
       }
-      llvmInfo.typeName= (cast<MDString>(typeNameNode->getOperand(opID)))->getString();
-      llvmInfo.typeQual = (cast<MDString>(typeQualNode->getOperand(opID)))->getString();
+      llvmInfo.typeName= (cast<MDString>(typeNameNode->getOperand(opID)))->getString().str();
+      llvmInfo.typeQual = (cast<MDString>(typeQualNode->getOperand(opID)))->getString().str();
       bool isImage = llvmInfo.isImageType();
       bool isPipe = llvmInfo.isPipeType();
       if (I->getType()->isPointerTy() || isImage || isPipe) {
@@ -1531,7 +1531,7 @@
             EltTy = getEltType(EltTy, TypeIndex);
         }
 
-        ir::Constant cc = unit.getConstantSet().getConstant(pointer->getName());
+        ir::Constant cc = unit.getConstantSet().getConstant(pointer->getName().str());
         unsigned int defOffset = cc.getOffset();
         relocs.push_back(ir::RelocEntry(offset, defOffset + constantOffset));
 
@@ -1546,7 +1546,7 @@
       return;
     }
     if (isa<GlobalVariable>(c)) {
-      ir::Constant cc = unit.getConstantSet().getConstant(c->getName());
+      ir::Constant cc = unit.getConstantSet().getConstant(c->getName().str());
       unsigned int defOffset = cc.getOffset();
 
       relocs.push_back(ir::RelocEntry(offset, defOffset));
@@ -1609,7 +1609,7 @@
           }
           break;
         }
-      case Type::TypeID::VectorTyID:
+      case Type::TypeID::FixedVectorTyID:
         {
           const ConstantDataSequential *cds = dyn_cast<ConstantDataSequential>(c);
           const VectorType *vecTy = cast<VectorType>(type);
@@ -1936,7 +1936,7 @@
       case Type::PointerTyID:
         regTranslator.newScalar(value, key, 0, uniform);
         break;
-      case Type::VectorTyID:
+      case Type::FixedVectorTyID:
       {
         auto vectorType = cast<VectorType>(type);
         const uint32_t elemNum = vectorType->getNumElements();
@@ -2395,7 +2395,7 @@
 #endif
         }
         if(typeNameNode) {
-          llvmInfo.typeName = (cast<MDString>(typeNameNode->getOperand(opID)))->getString();
+          llvmInfo.typeName = (cast<MDString>(typeNameNode->getOperand(opID)))->getString().str();
           //LLVM 3.9 image's type name include access qual, don't match OpenCL spec, erase them.
           std::vector<std::string> filters = {"__read_only ", "__write_only "};
           for (uint32_t i = 0; i < filters.size(); i++) {
@@ -2406,16 +2406,16 @@
           }
         }
         if(typeBaseNameNode){
-          llvmInfo.typeBaseName = (cast<MDString>(typeBaseNameNode->getOperand(opID)))->getString();
+          llvmInfo.typeBaseName = (cast<MDString>(typeBaseNameNode->getOperand(opID)))->getString().str();
         }
         if(accessQualNode) {
-          llvmInfo.accessQual = (cast<MDString>(accessQualNode->getOperand(opID)))->getString();
+          llvmInfo.accessQual = (cast<MDString>(accessQualNode->getOperand(opID)))->getString().str();
         }
         if(typeQualNode) {
-          llvmInfo.typeQual = (cast<MDString>(typeQualNode->getOperand(opID)))->getString();
+          llvmInfo.typeQual = (cast<MDString>(typeQualNode->getOperand(opID)))->getString().str();
         }
         if(argNameNode){
-          llvmInfo.argName = (cast<MDString>(argNameNode->getOperand(opID)))->getString();
+          llvmInfo.argName = (cast<MDString>(argNameNode->getOperand(opID)))->getString().str();
         }
 
         // function arguments are uniform values.
@@ -3010,7 +3010,7 @@
         } else {
           this->newRegister(const_cast<GlobalVariable*>(&v));
           ir::Register reg = regTranslator.getScalar(const_cast<GlobalVariable*>(&v), 0);
-          ir::Constant &con = unit.getConstantSet().getConstant(v.getName());
+          ir::Constant &con = unit.getConstantSet().getConstant(v.getName().str());
           if (!legacyMode) {
             ir::Register regload = ctx.reg(getFamily(getType(ctx, v.getType())));
             ctx.LOADI(getType(ctx, v.getType()), regload, ctx.newIntegerImmediate(con.getOffset(), getType(ctx, v.getType())));
@@ -3212,7 +3212,7 @@
         GBE_ASSERTM(false, "Unsupported calling convention");
     }
 
-    ctx.startFunction(F.getName());
+    ctx.startFunction(F.getName().str());
 
     ir::Function &fn = ctx.getFunction();
     this->regTranslator.clear();
@@ -3810,9 +3810,9 @@
 
   void GenWriter::regAllocateCallInst(CallInst &I) {
     Value *dst = &I;
-    Value *Callee = I.getCalledValue();
+    Value *Callee = I.getCalledOperand();
     GBE_ASSERT(ctx.getFunction().getProfile() == ir::PROFILE_OCL);
-    GBE_ASSERT(isa<InlineAsm>(I.getCalledValue()) == false);
+    GBE_ASSERT(isa<InlineAsm>(I.getCalledOperand()) == false);
     if(I.getNumArgOperands()) GBE_ASSERT(I.hasStructRetAttr() == false);
 
     // We only support a small number of intrinsics right now
@@ -3870,7 +3870,7 @@
       }
     }
     // Get the name of the called function and handle it
-    const std::string fnName = Callee->stripPointerCasts()->getName();
+    const std::string fnName = Callee->stripPointerCasts()->getName().str();
     auto genIntrinsicID = intrinsicMap.find(fnName);
     switch (genIntrinsicID) {
       case GEN_OCL_GET_GROUP_ID0:
@@ -4166,7 +4166,7 @@
     };
   }
 
-  void GenWriter::emitRoundingCallInst(CallInst &I, CallSite &CS, ir::Opcode opcode) {
+  void GenWriter::emitRoundingCallInst(CallInst &I, CallBase &CS, ir::Opcode opcode) {
     if (I.getType()->isHalfTy()) {
       const ir::Register src = this->getRegister(I.getOperand(0));
       const ir::Register srcFloat = ctx.reg(ir::FAMILY_DWORD);
@@ -4181,10 +4181,10 @@
     }
   }
 
-  void GenWriter::emitUnaryCallInst(CallInst &I, CallSite &CS, ir::Opcode opcode, ir::Type type) {
-    CallSite::arg_iterator AI = CS.arg_begin();
+  void GenWriter::emitUnaryCallInst(CallInst &I, CallBase &CS, ir::Opcode opcode, ir::Type type) {
+    auto AI = CS.arg_begin();
 #if GBE_DEBUG
-    CallSite::arg_iterator AE = CS.arg_end();
+    auto AE = CS.arg_end();
 #endif /* GBE_DEBUG */
     GBE_ASSERT(AI != AE);
     const ir::Register src = this->getRegister(*AI);
@@ -4292,9 +4292,9 @@
     this->emitAtomicInstHelper(opcode, type, dst, llvmPtr, payloadTuple);
   }
 
-  void GenWriter::emitAtomicInst(CallInst &I, CallSite &CS, ir::AtomicOps opcode) {
-    CallSite::arg_iterator AI = CS.arg_begin();
-    CallSite::arg_iterator AE = CS.arg_end();
+  void GenWriter::emitAtomicInst(CallInst &I, CallBase &CS, ir::AtomicOps opcode) {
+    auto AI = CS.arg_begin();
+    auto AE = CS.arg_end();
     GBE_ASSERT(AI != AE);
     Value *llvmPtr = *AI;
     ir::AddressSpace addrSpace = addressSpaceLLVMToGen(llvmPtr->getType()->getPointerAddressSpace());
@@ -4347,7 +4347,7 @@
     }
   }
 
-  void GenWriter::emitWorkGroupInst(CallInst &I, CallSite &CS, ir::WorkGroupOps opcode) {
+  void GenWriter::emitWorkGroupInst(CallInst &I, CallBase &CS, ir::WorkGroupOps opcode) {
     ir::Function &f = ctx.getFunction();
 
     if (f.getwgBroadcastSLM() < 0 && opcode == ir::WORKGROUP_OP_BROADCAST) {
@@ -4377,8 +4377,8 @@
       GBE_ASSERT(f.gettidMapSLM() >= 0);
     }
 
-    CallSite::arg_iterator AI = CS.arg_begin();
-    CallSite::arg_iterator AE = CS.arg_end();
+    auto AI = CS.arg_begin();
+    auto AE = CS.arg_end();
     GBE_ASSERT(AI != AE);
 
     if (opcode == ir::WORKGROUP_OP_ALL || opcode == ir::WORKGROUP_OP_ANY) {
@@ -4422,9 +4422,9 @@
     GBE_ASSERT(AI == AE);
   }
 
-  void GenWriter::emitSubGroupInst(CallInst &I, CallSite &CS, ir::WorkGroupOps opcode) {
-    CallSite::arg_iterator AI = CS.arg_begin();
-    CallSite::arg_iterator AE = CS.arg_end();
+  void GenWriter::emitSubGroupInst(CallInst &I, CallBase &CS, ir::WorkGroupOps opcode) {
+    auto AI = CS.arg_begin();
+    auto AE = CS.arg_end();
     GBE_ASSERT(AI != AE);
 
     if (opcode == ir::WORKGROUP_OP_ALL || opcode == ir::WORKGROUP_OP_ANY) {
@@ -4465,9 +4465,9 @@
     GBE_ASSERT(AI == AE);
   }
 
-  void GenWriter::emitBlockReadWriteMemInst(CallInst &I, CallSite &CS, bool isWrite, uint8_t vec_size, ir::Type type) {
-    CallSite::arg_iterator AI = CS.arg_begin();
-    CallSite::arg_iterator AE = CS.arg_end();
+  void GenWriter::emitBlockReadWriteMemInst(CallInst &I, CallBase &CS, bool isWrite, uint8_t vec_size, ir::Type type) {
+    auto AI = CS.arg_begin();
+    auto AE = CS.arg_end();
     GBE_ASSERT(AI != AE);
 
     Value *llvmPtr = *(AI++);
@@ -4521,9 +4521,9 @@
     GBE_ASSERT(AI == AE);
   }
 
-  void GenWriter::emitBlockReadWriteImageInst(CallInst &I, CallSite &CS, bool isWrite, uint8_t vec_size, ir::Type type) {
-    CallSite::arg_iterator AI = CS.arg_begin();
-    CallSite::arg_iterator AE = CS.arg_end();
+  void GenWriter::emitBlockReadWriteImageInst(CallInst &I, CallBase &CS, bool isWrite, uint8_t vec_size, ir::Type type) {
+    auto AI = CS.arg_begin();
+    auto AE = CS.arg_end();
     GBE_ASSERT(AI != AE);
 
     const uint8_t imageID = getImageID(I);
@@ -4556,7 +4556,7 @@
 
   /* append a new sampler. should be called before any reference to
    * a sampler_t value. */
-  uint8_t GenWriter::appendSampler(CallSite::arg_iterator AI) {
+  uint8_t GenWriter::appendSampler(User::op_iterator AI) {
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
     CallInst *TC = dyn_cast<CallInst>(*AI);
     Constant *CPV = TC ? dyn_cast<Constant>(TC->getOperand(0)) : NULL;
@@ -4594,10 +4594,10 @@
         const ir::Function &fn = ctx.getFunction();
 
         // Get the function arguments
-        CallSite CS(&I);
-        CallSite::arg_iterator AI = CS.arg_begin();
+        CallBase *CS = dyn_cast<CallBase>(&I);
+        auto AI = CS->arg_begin();
 #if GBE_DEBUG
-        CallSite::arg_iterator AE = CS.arg_end();
+        auto AE = CS->arg_end();
 #endif /* GBE_DEBUG */
         switch (F->getIntrinsicID()) {
           case Intrinsic::stacksave:
@@ -4763,17 +4763,17 @@
             ctx.MAD(srcType, dst, src0, src1, src2);
           }
           break;
-          case Intrinsic::sqrt: this->emitUnaryCallInst(I,CS,ir::OP_SQR); break;
-          case Intrinsic::ceil: this->emitRoundingCallInst(I,CS,ir::OP_RNDU); break;
-          case Intrinsic::trunc: this->emitRoundingCallInst(I,CS,ir::OP_RNDZ); break;
-          case Intrinsic::rint: this->emitRoundingCallInst(I,CS,ir::OP_RNDE); break;
-          case Intrinsic::floor: this->emitRoundingCallInst(I,CS,ir::OP_RNDD); break;
-          case Intrinsic::sin: this->emitUnaryCallInst(I,CS,ir::OP_SIN); break;
-          case Intrinsic::cos: this->emitUnaryCallInst(I,CS,ir::OP_COS); break;
-          case Intrinsic::log2: this->emitUnaryCallInst(I,CS,ir::OP_LOG); break;
-          case Intrinsic::exp2: this->emitUnaryCallInst(I,CS,ir::OP_EXP); break;
+          case Intrinsic::sqrt: this->emitUnaryCallInst(I,*CS,ir::OP_SQR); break;
+          case Intrinsic::ceil: this->emitRoundingCallInst(I,*CS,ir::OP_RNDU); break;
+          case Intrinsic::trunc: this->emitRoundingCallInst(I,*CS,ir::OP_RNDZ); break;
+          case Intrinsic::rint: this->emitRoundingCallInst(I,*CS,ir::OP_RNDE); break;
+          case Intrinsic::floor: this->emitRoundingCallInst(I,*CS,ir::OP_RNDD); break;
+          case Intrinsic::sin: this->emitUnaryCallInst(I,*CS,ir::OP_SIN); break;
+          case Intrinsic::cos: this->emitUnaryCallInst(I,*CS,ir::OP_COS); break;
+          case Intrinsic::log2: this->emitUnaryCallInst(I,*CS,ir::OP_LOG); break;
+          case Intrinsic::exp2: this->emitUnaryCallInst(I,*CS,ir::OP_EXP); break;
           case Intrinsic::bswap:
-            this->emitUnaryCallInst(I,CS,ir::OP_BSWAP, getUnsignedType(ctx, I.getType())); break;
+            this->emitUnaryCallInst(I,*CS,ir::OP_BSWAP, getUnsignedType(ctx, I.getType())); break;
           case Intrinsic::pow:
           {
             const ir::Register src0 = this->getRegister(*AI); ++AI;
@@ -4793,21 +4793,21 @@
         }
       } else {
         // Get the name of the called function and handle it
-        Value *Callee = I.getCalledValue();
-        const std::string fnName = Callee->stripPointerCasts()->getName();
+        Value *Callee = I.getCalledOperand();
+        const std::string fnName = Callee->stripPointerCasts()->getName().str();
         auto genIntrinsicID = intrinsicMap.find(fnName);
 
         // Get the function arguments
-        CallSite CS(&I);
-        CallSite::arg_iterator AI = CS.arg_begin();
+        CallBase *CS = dyn_cast<CallBase>(&I);
+        auto AI = CS->arg_begin();
 #if GBE_DEBUG
-        CallSite::arg_iterator AE = CS.arg_end();
+        auto AE = CS->arg_end();
 #endif /* GBE_DEBUG */
 
         switch (genIntrinsicID) {
-          case GEN_OCL_FBH: this->emitUnaryCallInst(I,CS,ir::OP_FBH, ir::TYPE_U32); break;
-          case GEN_OCL_FBL: this->emitUnaryCallInst(I,CS,ir::OP_FBL, ir::TYPE_U32); break;
-          case GEN_OCL_CBIT: this->emitUnaryCallInst(I,CS,ir::OP_CBIT, getUnsignedType(ctx, (*AI)->getType())); break;
+          case GEN_OCL_FBH: this->emitUnaryCallInst(I,*CS,ir::OP_FBH, ir::TYPE_U32); break;
+          case GEN_OCL_FBL: this->emitUnaryCallInst(I,*CS,ir::OP_FBL, ir::TYPE_U32); break;
+          case GEN_OCL_CBIT: this->emitUnaryCallInst(I,*CS,ir::OP_CBIT, getUnsignedType(ctx, (*AI)->getType())); break;
           case GEN_OCL_ABS:
           {
             const ir::Register src = this->getRegister(*AI);
@@ -4914,8 +4914,8 @@
             ctx.REGION(dst, src, x.getIntegerValue());
             break;
           }
-          case GEN_OCL_RSQ: this->emitUnaryCallInst(I,CS,ir::OP_RSQ); break;
-          case GEN_OCL_RCP: this->emitUnaryCallInst(I,CS,ir::OP_RCP); break;
+          case GEN_OCL_RSQ: this->emitUnaryCallInst(I,*CS,ir::OP_RSQ); break;
+          case GEN_OCL_RCP: this->emitUnaryCallInst(I,*CS,ir::OP_RCP); break;
           case GEN_OCL_FORCE_SIMD8: ctx.setSimdWidth(8); break;
           case GEN_OCL_FORCE_SIMD16: ctx.setSimdWidth(16); break;
           case GEN_OCL_LBARRIER: ctx.SYNC(ir::syncLocalBarrier); break;
@@ -4946,31 +4946,31 @@
             break;
           }
           case GEN_OCL_ATOMIC_ADD0:
-          case GEN_OCL_ATOMIC_ADD1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_ADD); break;
+          case GEN_OCL_ATOMIC_ADD1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_ADD); break;
           case GEN_OCL_ATOMIC_SUB0:
-          case GEN_OCL_ATOMIC_SUB1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_SUB); break;
+          case GEN_OCL_ATOMIC_SUB1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_SUB); break;
           case GEN_OCL_ATOMIC_AND0:
-          case GEN_OCL_ATOMIC_AND1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_AND); break;
+          case GEN_OCL_ATOMIC_AND1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_AND); break;
           case GEN_OCL_ATOMIC_OR0:
-          case GEN_OCL_ATOMIC_OR1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_OR); break;
+          case GEN_OCL_ATOMIC_OR1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_OR); break;
           case GEN_OCL_ATOMIC_XOR0:
-          case GEN_OCL_ATOMIC_XOR1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_XOR); break;
+          case GEN_OCL_ATOMIC_XOR1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_XOR); break;
           case GEN_OCL_ATOMIC_XCHG0:
-          case GEN_OCL_ATOMIC_XCHG1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_XCHG); break;
+          case GEN_OCL_ATOMIC_XCHG1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_XCHG); break;
           case GEN_OCL_ATOMIC_INC0:
-          case GEN_OCL_ATOMIC_INC1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_INC); break;
+          case GEN_OCL_ATOMIC_INC1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_INC); break;
           case GEN_OCL_ATOMIC_DEC0:
-          case GEN_OCL_ATOMIC_DEC1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_DEC); break;
+          case GEN_OCL_ATOMIC_DEC1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_DEC); break;
           case GEN_OCL_ATOMIC_UMIN0:
-          case GEN_OCL_ATOMIC_UMIN1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_UMIN); break;
+          case GEN_OCL_ATOMIC_UMIN1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_UMIN); break;
           case GEN_OCL_ATOMIC_UMAX0:
-          case GEN_OCL_ATOMIC_UMAX1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_UMAX); break;
+          case GEN_OCL_ATOMIC_UMAX1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_UMAX); break;
           case GEN_OCL_ATOMIC_IMIN0:
-          case GEN_OCL_ATOMIC_IMIN1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_IMIN); break;
+          case GEN_OCL_ATOMIC_IMIN1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_IMIN); break;
           case GEN_OCL_ATOMIC_IMAX0:
-          case GEN_OCL_ATOMIC_IMAX1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_IMAX); break;
+          case GEN_OCL_ATOMIC_IMAX1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_IMAX); break;
           case GEN_OCL_ATOMIC_CMPXCHG0:
-          case GEN_OCL_ATOMIC_CMPXCHG1: this->emitAtomicInst(I,CS,ir::ATOMIC_OP_CMPXCHG); break;
+          case GEN_OCL_ATOMIC_CMPXCHG1: this->emitAtomicInst(I,*CS,ir::ATOMIC_OP_CMPXCHG); break;
           case GEN_OCL_GET_IMAGE_WIDTH:
           case GEN_OCL_GET_IMAGE_HEIGHT:
           case GEN_OCL_GET_IMAGE_DEPTH:
@@ -5428,48 +5428,48 @@
             ctx.WAIT();
             break;
           }
-          case GEN_OCL_WORK_GROUP_ALL: this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_ALL); break;
-          case GEN_OCL_WORK_GROUP_ANY: this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_ANY); break;
+          case GEN_OCL_WORK_GROUP_ALL: this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_ALL); break;
+          case GEN_OCL_WORK_GROUP_ANY: this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_ANY); break;
           case GEN_OCL_WORK_GROUP_BROADCAST:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_BROADCAST); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_BROADCAST); break;
           case GEN_OCL_WORK_GROUP_REDUCE_ADD:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_REDUCE_ADD); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_REDUCE_ADD); break;
           case GEN_OCL_WORK_GROUP_REDUCE_MAX:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_REDUCE_MAX); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_REDUCE_MAX); break;
           case GEN_OCL_WORK_GROUP_REDUCE_MIN:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_REDUCE_MIN); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_REDUCE_MIN); break;
           case GEN_OCL_WORK_GROUP_SCAN_EXCLUSIVE_ADD:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_EXCLUSIVE_ADD); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_EXCLUSIVE_ADD); break;
           case GEN_OCL_WORK_GROUP_SCAN_EXCLUSIVE_MAX:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_EXCLUSIVE_MAX); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_EXCLUSIVE_MAX); break;
           case GEN_OCL_WORK_GROUP_SCAN_EXCLUSIVE_MIN:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_EXCLUSIVE_MIN); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_EXCLUSIVE_MIN); break;
           case GEN_OCL_WORK_GROUP_SCAN_INCLUSIVE_ADD:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_INCLUSIVE_ADD); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_INCLUSIVE_ADD); break;
           case GEN_OCL_WORK_GROUP_SCAN_INCLUSIVE_MAX:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_INCLUSIVE_MAX); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_INCLUSIVE_MAX); break;
           case GEN_OCL_WORK_GROUP_SCAN_INCLUSIVE_MIN:
-            this->emitWorkGroupInst(I, CS, ir::WORKGROUP_OP_INCLUSIVE_MIN); break;
+            this->emitWorkGroupInst(I, *CS, ir::WORKGROUP_OP_INCLUSIVE_MIN); break;
           case GEN_OCL_SUB_GROUP_BROADCAST:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_BROADCAST); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_BROADCAST); break;
           case GEN_OCL_SUB_GROUP_REDUCE_ADD:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_REDUCE_ADD); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_REDUCE_ADD); break;
           case GEN_OCL_SUB_GROUP_REDUCE_MAX:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_REDUCE_MAX); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_REDUCE_MAX); break;
           case GEN_OCL_SUB_GROUP_REDUCE_MIN:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_REDUCE_MIN); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_REDUCE_MIN); break;
           case GEN_OCL_SUB_GROUP_SCAN_EXCLUSIVE_ADD:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_EXCLUSIVE_ADD); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_EXCLUSIVE_ADD); break;
           case GEN_OCL_SUB_GROUP_SCAN_EXCLUSIVE_MAX:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_EXCLUSIVE_MAX); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_EXCLUSIVE_MAX); break;
           case GEN_OCL_SUB_GROUP_SCAN_EXCLUSIVE_MIN:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_EXCLUSIVE_MIN); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_EXCLUSIVE_MIN); break;
           case GEN_OCL_SUB_GROUP_SCAN_INCLUSIVE_ADD:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_INCLUSIVE_ADD); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_INCLUSIVE_ADD); break;
           case GEN_OCL_SUB_GROUP_SCAN_INCLUSIVE_MAX:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_INCLUSIVE_MAX); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_INCLUSIVE_MAX); break;
           case GEN_OCL_SUB_GROUP_SCAN_INCLUSIVE_MIN:
-            this->emitSubGroupInst(I, CS, ir::WORKGROUP_OP_INCLUSIVE_MIN); break;
+            this->emitSubGroupInst(I, *CS, ir::WORKGROUP_OP_INCLUSIVE_MIN); break;
           case GEN_OCL_LRP:
           {
             const ir::Register dst  = this->getRegister(&I);
@@ -5483,69 +5483,69 @@
             break;
           }
           case GEN_OCL_SUB_GROUP_BLOCK_READ_UI_MEM:
-            this->emitBlockReadWriteMemInst(I, CS, false, 1); break;
+            this->emitBlockReadWriteMemInst(I, *CS, false, 1); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_UI_MEM2:
-            this->emitBlockReadWriteMemInst(I, CS, false, 2); break;
+            this->emitBlockReadWriteMemInst(I, *CS, false, 2); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_UI_MEM4:
-            this->emitBlockReadWriteMemInst(I, CS, false, 4); break;
+            this->emitBlockReadWriteMemInst(I, *CS, false, 4); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_UI_MEM8:
-            this->emitBlockReadWriteMemInst(I, CS, false, 8); break;
+            this->emitBlockReadWriteMemInst(I, *CS, false, 8); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_UI_MEM:
-            this->emitBlockReadWriteMemInst(I, CS, true, 1); break;
+            this->emitBlockReadWriteMemInst(I, *CS, true, 1); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_UI_MEM2:
-            this->emitBlockReadWriteMemInst(I, CS, true, 2); break;
+            this->emitBlockReadWriteMemInst(I, *CS, true, 2); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_UI_MEM4:
-            this->emitBlockReadWriteMemInst(I, CS, true, 4); break;
+            this->emitBlockReadWriteMemInst(I, *CS, true, 4); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_UI_MEM8:
-            this->emitBlockReadWriteMemInst(I, CS, true, 8); break;
+            this->emitBlockReadWriteMemInst(I, *CS, true, 8); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_UI_IMAGE:
-            this->emitBlockReadWriteImageInst(I, CS, false, 1); break;
+            this->emitBlockReadWriteImageInst(I, *CS, false, 1); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_UI_IMAGE2:
-            this->emitBlockReadWriteImageInst(I, CS, false, 2); break;
+            this->emitBlockReadWriteImageInst(I, *CS, false, 2); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_UI_IMAGE4:
-            this->emitBlockReadWriteImageInst(I, CS, false, 4); break;
+            this->emitBlockReadWriteImageInst(I, *CS, false, 4); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_UI_IMAGE8:
-            this->emitBlockReadWriteImageInst(I, CS, false, 8); break;
+            this->emitBlockReadWriteImageInst(I, *CS, false, 8); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_UI_IMAGE:
-            this->emitBlockReadWriteImageInst(I, CS, true, 1); break;
+            this->emitBlockReadWriteImageInst(I, *CS, true, 1); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_UI_IMAGE2:
-            this->emitBlockReadWriteImageInst(I, CS, true, 2); break;
+            this->emitBlockReadWriteImageInst(I, *CS, true, 2); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_UI_IMAGE4:
-            this->emitBlockReadWriteImageInst(I, CS, true, 4); break;
+            this->emitBlockReadWriteImageInst(I, *CS, true, 4); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_UI_IMAGE8:
-            this->emitBlockReadWriteImageInst(I, CS, true, 8); break;
+            this->emitBlockReadWriteImageInst(I, *CS, true, 8); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_US_MEM:
-            this->emitBlockReadWriteMemInst(I, CS, false, 1, ir::TYPE_U16); break;
+            this->emitBlockReadWriteMemInst(I, *CS, false, 1, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_US_MEM2:
-            this->emitBlockReadWriteMemInst(I, CS, false, 2, ir::TYPE_U16); break;
+            this->emitBlockReadWriteMemInst(I, *CS, false, 2, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_US_MEM4:
-            this->emitBlockReadWriteMemInst(I, CS, false, 4, ir::TYPE_U16); break;
+            this->emitBlockReadWriteMemInst(I, *CS, false, 4, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_US_MEM8:
-            this->emitBlockReadWriteMemInst(I, CS, false, 8, ir::TYPE_U16); break;
+            this->emitBlockReadWriteMemInst(I, *CS, false, 8, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_US_MEM:
-            this->emitBlockReadWriteMemInst(I, CS, true, 1, ir::TYPE_U16); break;
+            this->emitBlockReadWriteMemInst(I, *CS, true, 1, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_US_MEM2:
-            this->emitBlockReadWriteMemInst(I, CS, true, 2, ir::TYPE_U16); break;
+            this->emitBlockReadWriteMemInst(I, *CS, true, 2, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_US_MEM4:
-            this->emitBlockReadWriteMemInst(I, CS, true, 4, ir::TYPE_U16); break;
+            this->emitBlockReadWriteMemInst(I, *CS, true, 4, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_US_MEM8:
-            this->emitBlockReadWriteMemInst(I, CS, true, 8, ir::TYPE_U16); break;
+            this->emitBlockReadWriteMemInst(I, *CS, true, 8, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_US_IMAGE:
-            this->emitBlockReadWriteImageInst(I, CS, false, 1, ir::TYPE_U16); break;
+            this->emitBlockReadWriteImageInst(I, *CS, false, 1, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_US_IMAGE2:
-            this->emitBlockReadWriteImageInst(I, CS, false, 2, ir::TYPE_U16); break;
+            this->emitBlockReadWriteImageInst(I, *CS, false, 2, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_US_IMAGE4:
-            this->emitBlockReadWriteImageInst(I, CS, false, 4, ir::TYPE_U16); break;
+            this->emitBlockReadWriteImageInst(I, *CS, false, 4, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_READ_US_IMAGE8:
-            this->emitBlockReadWriteImageInst(I, CS, false, 8, ir::TYPE_U16); break;
+            this->emitBlockReadWriteImageInst(I, *CS, false, 8, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_US_IMAGE:
-            this->emitBlockReadWriteImageInst(I, CS, true, 1, ir::TYPE_U16); break;
+            this->emitBlockReadWriteImageInst(I, *CS, true, 1, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_US_IMAGE2:
-            this->emitBlockReadWriteImageInst(I, CS, true, 2, ir::TYPE_U16); break;
+            this->emitBlockReadWriteImageInst(I, *CS, true, 2, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_US_IMAGE4:
-            this->emitBlockReadWriteImageInst(I, CS, true, 4, ir::TYPE_U16); break;
+            this->emitBlockReadWriteImageInst(I, *CS, true, 4, ir::TYPE_U16); break;
           case GEN_OCL_SUB_GROUP_BLOCK_WRITE_US_IMAGE8:
-            this->emitBlockReadWriteImageInst(I, CS, true, 8, ir::TYPE_U16); break;
+            this->emitBlockReadWriteImageInst(I, *CS, true, 8, ir::TYPE_U16); break;
           case GEN_OCL_GET_PIPE:
           case GEN_OCL_MAKE_RID:
           case GEN_OCL_GET_RID:
diff -urN Beignet-1.3.2-Source/backend/src/llvm/llvm_loadstore_optimization.cpp Beignet-1.3.2-Source.new/backend/src/llvm/llvm_loadstore_optimization.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/llvm_loadstore_optimization.cpp	2021-03-05 00:22:37.644846897 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/llvm_loadstore_optimization.cpp	2021-03-05 00:21:13.516608757 +0300
@@ -154,8 +154,10 @@
     LoadInst *ld = cast<LoadInst>(merged[0]);
 #if LLVM_VERSION_MAJOR < 10
     unsigned align = ld->getAlignment();
-#else
+#elif LLVM_VERSION_MAJOR < 11
     MaybeAlign align = ld->getAlign();
+#else
+    Align align = ld->getAlign();
 #endif
     unsigned addrSpace = ld->getPointerAddressSpace();
     // insert before first load
@@ -241,8 +243,10 @@
 
 #if LLVM_VERSION_MAJOR < 10
     unsigned align = st->getAlignment();
-#else
+#elif LLVM_VERSION_MAJOR < 11
     MaybeAlign align = st->getAlign();
+#else
+    Align align = st->getAlign();
 #endif
     // insert before the last store
     Builder.SetInsertPoint(merged[size-1]);
diff -urN Beignet-1.3.2-Source/backend/src/llvm/llvm_passes.cpp Beignet-1.3.2-Source.new/backend/src/llvm/llvm_passes.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/llvm_passes.cpp	2021-03-05 00:22:37.644846897 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/llvm_passes.cpp	2021-03-04 23:51:15.525151975 +0300
@@ -94,7 +94,7 @@
   {
     switch (Ty->getTypeID()) {
       case Type::VoidTyID: NOT_SUPPORTED;
-      case Type::VectorTyID:
+      case Type::FixedVectorTyID:
       {
         const VectorType* VecTy = cast<VectorType>(Ty);
         uint32_t elemNum = VecTy->getNumElements();
@@ -138,7 +138,7 @@
       case Type::HalfTyID:    return 16;
       case Type::FloatTyID:   return 32;
       case Type::DoubleTyID:  return 64;
-      case Type::VectorTyID:
+      case Type::FixedVectorTyID:
       {
         const VectorType* VecTy = cast<VectorType>(Ty);
         uint32_t numElem = VecTy->getNumElements();
@@ -184,9 +184,9 @@
     Type *elementType = NULL;
     if (PointerType* ptrType = dyn_cast<PointerType>(eltTy))
       elementType = ptrType->getElementType();
-    else if(SequentialType * seqType = dyn_cast<SequentialType>(eltTy))
+    else if(ArrayType * seqType = dyn_cast<ArrayType>(eltTy))
       elementType = seqType->getElementType();
-    else if(CompositeType * compTy= dyn_cast<CompositeType>(eltTy))
+    else if(StructType * compTy= dyn_cast<StructType>(eltTy))
       elementType = compTy->getTypeAtIndex(index);
     GBE_ASSERT(elementType);
     return elementType;
diff -urN Beignet-1.3.2-Source/backend/src/llvm/llvm_printf_parser.cpp Beignet-1.3.2-Source.new/backend/src/llvm/llvm_printf_parser.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/llvm_printf_parser.cpp	2017-10-24 09:04:48.000000000 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/llvm_printf_parser.cpp	2021-03-05 00:11:42.756222034 +0300
@@ -323,8 +323,8 @@
 
   bool PrintfParser::parseOnePrintfInstruction(CallInst * call)
   {
-    CallSite CS(call);
-    CallSite::arg_iterator CI_FMT = CS.arg_begin();
+    CallBase *CS = dyn_cast<CallBase>(call);
+    auto CI_FMT = CS->arg_begin();
     int param_num = 0;
 
     llvm::Constant* arg0 = dyn_cast<llvm::ConstantExpr>(*CI_FMT);
@@ -341,7 +341,7 @@
       return false;
     }
 
-    std::string fmt = fmt_arg->getAsCString();
+    std::string fmt = fmt_arg->getAsCString().str();
     if (fmt.size() == 0)
       return false;
 
@@ -437,8 +437,8 @@
         if ( callFunc->getIntrinsicID() != 0)
           continue;
 
-        Value *Callee = call->getCalledValue();
-        const std::string fnName = Callee->getName();
+        Value *Callee = call->getCalledOperand();
+        const std::string fnName = Callee->getName().str();
 
         if (fnName != "__gen_ocl_printf_stub" && fnName != "__gen_ocl_puts_stub")
           continue;
@@ -582,7 +582,7 @@
             if (!fmt_arg || !fmt_arg->isCString()) {
               return false;
             }
-            slot.state.str = fmt_arg->getAsCString();
+            slot.state.str = fmt_arg->getAsCString().str();
             return true;
           }
           case PRINTF_CONVERSION_P: {
@@ -595,10 +595,10 @@
 
         break;
 
-      case Type::VectorTyID: {
-        Type* vect_type = arg->getType();
-        Type* elt_type = vect_type->getVectorElementType();
-        int vec_num = vect_type->getVectorNumElements();
+      case Type::FixedVectorTyID: {
+        FixedVectorType* vect_type = dyn_cast<FixedVectorType>(arg->getType());
+        Type* elt_type = vect_type->getElementType();
+        int vec_num = vect_type->getNumElements();
         bool sign = false;
 
         if (vec_num != slot.state.vector_n) {
diff -urN Beignet-1.3.2-Source/backend/src/llvm/llvm_profiling.cpp Beignet-1.3.2-Source.new/backend/src/llvm/llvm_profiling.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/llvm_profiling.cpp	2021-03-05 00:22:37.642846867 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/llvm_profiling.cpp	2021-03-05 00:12:15.466702020 +0300
@@ -35,7 +35,6 @@
 #include "llvm/IR/IRBuilder.h"
 
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 35
-#include "llvm/IR/CallSite.h"
 #include "llvm/IR/CFG.h"
 #else
 #include "llvm/Support/CallSite.h"
diff -urN Beignet-1.3.2-Source/backend/src/llvm/llvm_sampler_fix.cpp Beignet-1.3.2-Source.new/backend/src/llvm/llvm_sampler_fix.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/llvm_sampler_fix.cpp	2021-03-05 00:22:37.644846897 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/llvm_sampler_fix.cpp	2021-03-04 21:45:05.132655190 +0300
@@ -45,8 +45,8 @@
     bool visitCallInst(CallInst *I) {
       if(!I)
         return false;
-      Value *Callee = I->getCalledValue();
-      const std::string fnName = Callee->getName();
+      Value *Callee = I->getCalledOperand();
+      const std::string fnName = Callee->getName().str();
       bool changed = false;
       Type *boolTy = IntegerType::get(I->getContext(), 1);
       Type *i32Ty = IntegerType::get(I->getContext(), 32);
@@ -59,7 +59,7 @@
         Value *needFixVal;
 #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
         CallInst *init = dyn_cast<CallInst>(I->getOperand(0));
-        if (init && init->getCalledValue()->getName().compare("__translate_sampler_initializer"))
+        if (init && init->getCalledOperand()->getName().compare("__translate_sampler_initializer"))
         {
           const ConstantInt *ci = dyn_cast<ConstantInt>(init->getOperand(0));
           uint32_t samplerInt = ci->getZExtValue();
@@ -113,7 +113,7 @@
         Value *needFixVal;
  #if LLVM_VERSION_MAJOR * 10 + LLVM_VERSION_MINOR >= 40
         CallInst *init = dyn_cast<CallInst>(I->getOperand(0));
-        if (init && init->getCalledValue()->getName().compare("__translate_sampler_initializer"))
+        if (init && init->getCalledOperand()->getName().compare("__translate_sampler_initializer"))
         {
           const ConstantInt *ci = dyn_cast<ConstantInt>(init->getOperand(0));
           uint32_t samplerInt = ci->getZExtValue();
diff -urN Beignet-1.3.2-Source/backend/src/llvm/llvm_scalarize.cpp Beignet-1.3.2-Source.new/backend/src/llvm/llvm_scalarize.cpp
--- Beignet-1.3.2-Source/backend/src/llvm/llvm_scalarize.cpp	2021-03-05 00:22:37.644846897 +0300
+++ Beignet-1.3.2-Source.new/backend/src/llvm/llvm_scalarize.cpp	2021-03-04 23:55:01.433475541 +0300
@@ -178,7 +178,7 @@
       if(!type)
         return type;
       switch(type->getTypeID()) {
-      case Type::VectorTyID:
+      case Type::FixedVectorTyID:
       case Type::ArrayTyID:
         return GetBasicType(type->getContainedType(0));
       default:
@@ -188,7 +188,7 @@
     }
 
     int GetComponentCount(const Type* type)  {
-      if (type && type->getTypeID() == Type::VectorTyID)
+      if (type && type->getTypeID() == Type::FixedVectorTyID)
         return llvm::dyn_cast<VectorType>(type)->getNumElements();
       else
         return 1;
@@ -652,13 +652,13 @@
           break;
         }
       } else {
-        Value *Callee = call->getCalledValue();
-        const std::string fnName = Callee->getName();
+        Value *Callee = call->getCalledOperand();
+        const std::string fnName = Callee->getName().str();
         auto genIntrinsicID = intrinsicMap.find(fnName);
 
         // Get the function arguments
-        CallSite CS(call);
-        CallSite::arg_iterator CI = CS.arg_begin() + 1;
+        CallBase *CS = dyn_cast<CallBase>(call);
+        auto CI = CS->arg_begin() + 1;
 
         switch (genIntrinsicID) {
           case GEN_OCL_NOT_FOUND:
@@ -729,7 +729,7 @@
             extractFromVector(call);
             break;
           case GEN_OCL_PRINTF:
-            for (; CI != CS.arg_end(); ++CI)
+            for (; CI != CS->arg_end(); ++CI)
               if ((*CI)->getType()->isVectorTy())
                 *CI = InsertToVector(call, *CI);
             break;
